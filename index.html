<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>3D Coin Rolling on a Plane (Top View)</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000011;
      font-family: Arial, sans-serif;
      overflow: hidden;
      color: white;
    }

    #controls {
      position: fixed;
      top: 10px;
      left: 10px;
      right: 10px;
      background: rgba(0,0,0,0.9);
      padding: 15px;
      border-radius: 10px;
      border: 2px solid #4444ff;
      z-index: 100;
      max-height: 60vh;
      overflow-y: auto;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    #controls.minimized {
      max-height: 50px;
      overflow: hidden;
    }

    #controls.minimized .control-content {
      display: none;
    }

    #minimizeBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #4444ff;
      border: none;
      color: white;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
    }

    @media (max-width: 768px) {
      #controls { top: 5px; left: 5px; right: 5px; padding: 10px; font-size: 12px; max-height: 50vh; }
      .control-group { margin: 8px 0; }
      label { font-size: 11px; margin-bottom: 3px; }
      select, input { width: 100%; padding: 6px; font-size: 12px; }
      .button { padding: 8px 12px; font-size: 11px; margin: 3px; }
    }

    .control-group { margin: 8px 0; display: flex; flex-direction: column; }
    .control-row { display: flex; gap: 15px; align-items: flex-start; }
    .control-column { flex: 1; display: flex; flex-direction: column; gap: 8px; }
    .button-row { display: flex; flex-wrap: wrap; gap: 5px; }

    label { display: block; margin-bottom: 5px; color: #88aaff; font-weight: bold; }
    select, input { width: 100%; max-width: 220px; padding: 8px; border-radius: 5px; border: 1px solid #4444ff; background: #001122; color: white; font-size: 14px; }

    .button {
      background: linear-gradient(45deg, #4444ff, #8888ff);
      border: none;
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      margin: 5px;
      font-weight: bold;
    }

    .button:hover { background: linear-gradient(45deg, #6666ff, #aaaaff); }

    .copyright {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: #6666aa;
      font-size: 12px;
      font-family: Arial, sans-serif;
      z-index: 100;
      background: rgba(0,0,0,0.7);
      padding: 5px 10px;
      border-radius: 5px;
    }

    .legend {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.6);
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #334;
      font-size: 12px;
    }

    #debugPanel {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 300px;
      max-height: 80vh;
      background: rgba(0,0,0,0.95);
      border: 2px solid #ff4444;
      border-radius: 8px;
      padding: 10px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #00ff00;
      overflow-y: auto;
      z-index: 200;
      display: none;
    }

    #debugPanel.visible {
      display: block;
    }

    #debugPanel h4 {
      margin: 0 0 10px 0;
      color: #ff4444;
      font-size: 12px;
    }

    #debugLog {
      background: rgba(0,0,0,0.8);
      border: 1px solid #333;
      padding: 8px;
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 10px;
      word-wrap: break-word;
    }

    .debug-section {
      margin-bottom: 10px;
      padding: 5px;
      border: 1px solid #333;
      border-radius: 3px;
    }

    .debug-toggle {
      position: fixed;
      top: 10px;
      right: 10px;
      background: #ff4444;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      z-index: 300;
      font-size: 11px;
    }

    @media (max-width: 768px) {
      #debugPanel {
        width: calc(100vw - 20px);
        right: 10px;
        left: 10px;
        top: 60px;
        max-height: 60vh;
      }
      .debug-toggle {
        top: 60px;
        right: 15px;
      }
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="minimizeBtn" onclick="toggleControls()">-</button>
    <h3>3D Rolling Coin (Realistic Physics)</h3>
    <div class="control-content">
      <div class="control-row">
        <div class="control-column">
          <div class="control-group">
            <label>Mass m (kg)</label>
            <input type="range" id="mass" min="0.1" max="5" step="0.1" value="1.0" />
            <span id="massValue">1.0</span>
          </div>
          <div class="control-group">
            <label>Radius R (px)</label>
            <input type="range" id="radius" min="20" max="150" step="1" value="60" />
            <span id="radiusValue">60</span>
          </div>
          <div class="control-group">
            <label>Thickness h (px)</label>
            <input type="range" id="thickness" min="1" max="40" step="1" value="8" />
            <span id="thicknessValue">8</span>
          </div>
          <div class="control-group">
            <label>Time Scale</label>
            <input type="range" id="timeScale" min="0.1" max="5" step="0.1" value="1" />
            <span id="timeScaleValue">1.0</span>
          </div>
        </div>
        <div class="control-column">
          <div class="control-group">
            <label>Initial Velocity X (px/s)</label>
            <input type="range" id="initVelX" min="-200" max="200" step="5" value="100" />
            <span id="initVelXValue">100</span>
          </div>
          <div class="control-group">
            <label>Initial Velocity Y (px/s)</label>
            <input type="range" id="initVelY" min="-200" max="200" step="5" value="0" />
            <span id="initVelYValue">0</span>
          </div>
          <div class="control-group">
            <label>Initial Angular Vel œâz (rad/s)</label>
            <input type="range" id="initOmegaZ" min="-20" max="20" step="0.5" value="0" />
            <span id="initOmegaZValue">0</span>
          </div>
          <div class="control-group">
            <label>Gravity g (px/s¬≤)</label>
            <input type="range" id="gravity" min="0" max="2000" step="50" value="980" />
            <span id="gravityValue">980</span>
          </div>
        </div>
        <div class="control-column">
          <div class="control-group">
            <label>Initial Tilt Œ∏ (deg)</label>
            <input type="range" id="tilt" min="70" max="90" step="1" value="85" />
            <span id="tiltValue">85</span>
          </div>
          <div class="control-group">
            <label>Heading œà (deg)</label>
            <input type="range" id="heading" min="0" max="360" step="1" value="0" />
            <span id="headingValue">0</span>
          </div>
          <div class="control-group">
            <label>Initial Spin Phase œÜ (deg)</label>
            <input type="range" id="spinPhase" min="0" max="360" step="1" value="0" />
            <span id="spinPhaseValue">0</span>
          </div>
          <div class="control-group">
            <label>Damping</label>
            <input type="range" id="damping" min="0" max="0.1" step="0.001" value="0.01" />
            <span id="dampingValue">0.01</span>
          </div>
        </div>
      </div>

      <div class="button-row">
        <button class="button" onclick="resetSimulation()">Reset</button>
        <button class="button" onclick="togglePause()">Pause</button>
        <button class="button" onclick="emergencyStop()" style="background-color: #ff4444; color: white; font-weight: bold;">STOP</button>
        <button class="button" onclick="toggleTrails()">Trails</button>
        <button class="button" onclick="setRandomMotion()">Random Motion</button>
        <button class="button" onclick="setPureRoll()">Pure Roll</button>
      </div>

      <div>
        <small>
          Realistic coin physics: proper no-slip constraint v_contact = 0, contact point at lowest rim point, torques from contact forces, energy conservation. Contact constraint: v_cm = -omega √ó r_contact where r_contact is from center to contact point.
        </small>
      </div>
    </div>
  </div>

  <div class="legend">Keys: Space = Pause, T = Trails, R = Reset, ESC/Ctrl+S = Emergency Stop | Axes: X=red, Y=green, Z=blue</div>
  <div class="copyright">¬© M.Zaiss'25 ¬∑ 3D Coin ¬∑ <a href="coin.html" target="_blank" style="color:#8888cc; text-decoration:none;">2D No-Slip</a></div>

  <button class="debug-toggle" id="debugToggle" onclick="toggleDebugPanel()">DEBUG</button>
  
  <div id="debugPanel">
    <h4>üêõ Debug Console</h4>
    
    <div class="debug-section">
      <div><strong>Error Log:</strong></div>
      <div id="debugLog"></div>
    </div>
    
    <div class="debug-section">
      <div><strong>Performance:</strong></div>
      <div id="debugPerf">
        FPS: <span id="fps">--</span><br>
        Frame Time: <span id="frameTime">--</span>ms<br>
        Memory: <span id="memory">--</span>MB
      </div>
    </div>
    
    <div class="debug-section">
      <div><strong>Physics State:</strong></div>
      <div id="debugState">
        Position: <span id="posDebug">--</span><br>
        Velocity: <span id="velDebug">--</span><br>
        Angular Vel: <span id="omegaDebug">--</span><br>
        Contact: <span id="contactDebug">--</span><br>
        Energy: <span id="energyDebug">--</span>
      </div>
    </div>
    
    <div class="debug-section">
      <div><strong>Browser Info:</strong></div>
      <div id="debugBrowser">
        User Agent: <span id="userAgent">--</span><br>
        Screen: <span id="screenSize">--</span><br>
        Viewport: <span id="viewportSize">--</span><br>
        Device Pixel Ratio: <span id="pixelRatio">--</span><br>
        Touch Support: <span id="touchSupport">--</span>
      </div>
    </div>
    
    <div class="debug-section">
      <div><strong>Canvas Info:</strong></div>
      <div id="debugCanvas">
        Canvas Size: <span id="canvasSize">--</span><br>
        Context: <span id="contextType">--</span><br>
        WebGL Support: <span id="webglSupport">--</span>
      </div>
    </div>
    
    <div class="debug-section">
      <button onclick="clearDebugLog()" style="background:#666;color:white;border:none;padding:4px 8px;border-radius:3px;">Clear Log</button>
      <button onclick="exportDebugInfo()" style="background:#666;color:white;border:none;padding:4px 8px;border-radius:3px;">Export Info</button>
    </div>
  </div>

  <script>
    // Debug system - Initialize early to catch all errors
    let debugPanel = null;
    let debugVisible = false;
    let debugLog = [];
    let lastFrameTime = performance.now();
    let frameCount = 0;
    let fpsUpdateTime = 0;
    
    // Override console methods to capture logs
    const originalConsole = {
      log: console.log,
      error: console.error,
      warn: console.warn,
      info: console.info
    };
    
    function addToDebugLog(type, message, timestamp = new Date()) {
      const logEntry = {
        type,
        message: String(message),
        timestamp: timestamp.toISOString().split('T')[1].slice(0, -1)
      };
      debugLog.push(logEntry);
      
      // Keep only last 100 entries
      if (debugLog.length > 100) {
        debugLog.shift();
      }
      
      updateDebugLogDisplay();
      
      // Call original console method
      if (originalConsole[type]) {
        originalConsole[type].apply(console, arguments);
      }
    }
    
    // Override console methods
    console.log = (...args) => addToDebugLog('log', args.join(' '));
    console.error = (...args) => addToDebugLog('error', args.join(' '));
    console.warn = (...args) => addToDebugLog('warn', args.join(' '));
    console.info = (...args) => addToDebugLog('info', args.join(' '));
    
    // Catch unhandled errors
    window.addEventListener('error', (event) => {
      addToDebugLog('error', `Unhandled Error: ${event.message} at ${event.filename}:${event.lineno}`);
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      addToDebugLog('error', `Unhandled Promise Rejection: ${event.reason}`);
    });
    
    function toggleDebugPanel() {
      debugVisible = !debugVisible;
      debugPanel = debugPanel || document.getElementById('debugPanel');
      if (debugPanel) {
        debugPanel.classList.toggle('visible', debugVisible);
        if (debugVisible) {
          updateAllDebugInfo();
        }
      }
    }
    
    function updateDebugLogDisplay() {
      const logElement = document.getElementById('debugLog');
      if (!logElement || !debugVisible) return;
      
      const logHtml = debugLog.slice(-20).map(entry => {
        const color = {
          error: '#ff4444',
          warn: '#ffaa44',
          info: '#4444ff',
          log: '#00ff00'
        }[entry.type] || '#00ff00';
        
        return `<div style="color:${color};">[${entry.timestamp}] ${entry.type.toUpperCase()}: ${entry.message}</div>`;
      }).join('');
      
      logElement.innerHTML = logHtml;
      logElement.scrollTop = logElement.scrollHeight;
    }
    
    function clearDebugLog() {
      debugLog = [];
      updateDebugLogDisplay();
    }
    
    function exportDebugInfo() {
      const info = {
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        screen: `${screen.width}x${screen.height}`,
        viewport: `${window.innerWidth}x${window.innerHeight}`,
        devicePixelRatio: window.devicePixelRatio,
        touchSupport: 'ontouchstart' in window,
        logs: debugLog,
        canvasSize: canvas ? `${canvas.width}x${canvas.height}` : 'N/A',
        webglSupport: !!window.WebGLRenderingContext
      };
      
      const dataStr = JSON.stringify(info, null, 2);
      const blob = new Blob([dataStr], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'debug-info.json';
      a.click();
      URL.revokeObjectURL(url);
    }
    
    function updateAllDebugInfo() {
      if (!debugVisible) return;
      
      // Browser info
      document.getElementById('userAgent').textContent = navigator.userAgent.slice(0, 50) + '...';
      document.getElementById('screenSize').textContent = `${screen.width}x${screen.height}`;
      document.getElementById('viewportSize').textContent = `${window.innerWidth}x${window.innerHeight}`;
      document.getElementById('pixelRatio').textContent = window.devicePixelRatio;
      document.getElementById('touchSupport').textContent = 'ontouchstart' in window ? 'Yes' : 'No';
      
      // Canvas info
      if (canvas) {
        document.getElementById('canvasSize').textContent = `${canvas.width}x${canvas.height}`;
        document.getElementById('contextType').textContent = ctx ? '2D' : 'None';
      }
      document.getElementById('webglSupport').textContent = !!window.WebGLRenderingContext ? 'Yes' : 'No';
      
      // Memory info (if available)
      if (performance.memory) {
        const memMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
        document.getElementById('memory').textContent = memMB;
      }
    }
    
    function updatePerformanceDebug() {
      if (!debugVisible) return;
      
      const now = performance.now();
      const deltaTime = now - lastFrameTime;
      lastFrameTime = now;
      frameCount++;
      
      // Update FPS every second
      if (now - fpsUpdateTime > 1000) {
        const fps = Math.round(frameCount * 1000 / (now - fpsUpdateTime));
        document.getElementById('fps').textContent = fps;
        frameCount = 0;
        fpsUpdateTime = now;
      }
      
      document.getElementById('frameTime').textContent = deltaTime.toFixed(1);
    }
    
    function updatePhysicsDebug() {
      if (!debugVisible) return;
      
      try {
        document.getElementById('posDebug').textContent = `(${pos[0].toFixed(1)}, ${pos[1].toFixed(1)}, ${pos[2].toFixed(1)})`;
        document.getElementById('velDebug').textContent = `(${vel[0].toFixed(1)}, ${vel[1].toFixed(1)}, ${vel[2].toFixed(1)})`;
        document.getElementById('omegaDebug').textContent = `(${omega[0].toFixed(2)}, ${omega[1].toFixed(2)}, ${omega[2].toFixed(2)})`;
        
        const contact_pos = getContactPoint();
        const in_contact = contact_pos[2] <= 0;
        document.getElementById('contactDebug').textContent = in_contact ? 'YES' : 'NO';
        
        const energy_kinetic = 0.5 * paramMass * (vel[0]*vel[0] + vel[1]*vel[1] + vel[2]*vel[2]);
        const omega_body = bodyFromWorld(omega);
        const energy_rotational = 0.5 * (I_perp * (omega_body[0]*omega_body[0] + omega_body[1]*omega_body[1]) + I_axis * omega_body[2]*omega_body[2]);
        const energy_total = energy_kinetic + energy_rotational + paramMass * paramGravity * pos[2];
        
        document.getElementById('energyDebug').textContent = energy_total.toFixed(0);
      } catch (e) {
        document.getElementById('posDebug').textContent = 'Error reading state';
      }
    }
    
    // Mobile touch debugging
    function setupTouchDebugging() {
      ['touchstart', 'touchmove', 'touchend', 'touchcancel'].forEach(eventType => {
        document.addEventListener(eventType, (e) => {
          console.log(`Touch ${eventType}: ${e.touches.length} touches, target:${e.target.tagName}`);
        }, { passive: false });
      });
      
      // Add orientation change debugging
      window.addEventListener('orientationchange', () => {
        console.log('Orientation changed to:', window.orientation || screen.orientation?.angle || 'unknown');
        setTimeout(() => {
          console.log('New viewport size after orientation change:', window.innerWidth + 'x' + window.innerHeight);
        }, 100);
      });
      
      // Add visibility change debugging
      document.addEventListener('visibilitychange', () => {
        console.log('Visibility changed. Hidden:', document.hidden);
      });
      
      // Add focus debugging
      window.addEventListener('focus', () => console.log('Window gained focus'));
      window.addEventListener('blur', () => console.log('Window lost focus'));
    }

    // Log initial startup
    console.log('=== 3D Coin App Starting ===');
    console.log('User Agent:', navigator.userAgent);
    console.log('Screen size:', screen.width + 'x' + screen.height);
    console.log('Viewport size:', window.innerWidth + 'x' + window.innerHeight);
    console.log('Device pixel ratio:', window.devicePixelRatio);
    console.log('Touch support:', 'ontouchstart' in window);
    console.log('Orientation:', window.orientation || screen.orientation?.angle || 'unknown');
    
    // Setup mobile debugging
    setupTouchDebugging();

    // Canvas setup
    const canvas = document.createElement('canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    document.body.appendChild(canvas);
    const ctx = canvas.getContext('2d');
    
    console.log('Canvas created:', canvas.width + 'x' + canvas.height);
    console.log('2D context available:', !!ctx);

    // UI elements
    const massEl = document.getElementById('mass');
    const radiusEl = document.getElementById('radius');
    const thicknessEl = document.getElementById('thickness');
    const timeEl = document.getElementById('timeScale');
    const initVelXEl = document.getElementById('initVelX');
    const initVelYEl = document.getElementById('initVelY');
    const initOmegaZEl = document.getElementById('initOmegaZ');
    const gravityEl = document.getElementById('gravity');
    const tiltEl = document.getElementById('tilt');
    const headingEl = document.getElementById('heading');
    const spinPhaseEl = document.getElementById('spinPhase');
    const dampingEl = document.getElementById('damping');

    function syncLabels() {
      document.getElementById('massValue').textContent = Number(massEl.value).toFixed(1);
      document.getElementById('radiusValue').textContent = Number(radiusEl.value).toFixed(0);
      document.getElementById('thicknessValue').textContent = Number(thicknessEl.value).toFixed(0);
      document.getElementById('timeScaleValue').textContent = Number(timeEl.value).toFixed(1);
      document.getElementById('initVelXValue').textContent = Number(initVelXEl.value).toFixed(0);
      document.getElementById('initVelYValue').textContent = Number(initVelYEl.value).toFixed(0);
      document.getElementById('initOmegaZValue').textContent = Number(initOmegaZEl.value).toFixed(1);
      document.getElementById('gravityValue').textContent = Number(gravityEl.value).toFixed(0);
      document.getElementById('tiltValue').textContent = Number(tiltEl.value).toFixed(0);
      document.getElementById('headingValue').textContent = Number(headingEl.value).toFixed(0);
      document.getElementById('spinPhaseValue').textContent = Number(spinPhaseEl.value).toFixed(0);
      document.getElementById('dampingValue').textContent = Number(dampingEl.value).toFixed(3);
    }

    // Live-apply parameter changes
    function applyParametersLive(){
      paramMass = Number(massEl.value);
      paramRadius = Number(radiusEl.value);
      paramThickness = Number(thicknessEl.value);
      paramGravity = Number(gravityEl.value);
      paramDamping = Number(dampingEl.value);
      I_perp = inertiaTransverse(paramMass, paramRadius, paramThickness);
      I_axis = inertiaAxial(paramMass, paramRadius);
      syncLabels();
    }

    [massEl, radiusEl, thicknessEl, gravityEl, dampingEl].forEach(el => 
      el.addEventListener('input', applyParametersLive)
    );
    timeEl.addEventListener('input', () => { paramTimeScale = Number(timeEl.value); syncLabels(); });
    [initVelXEl, initVelYEl, initOmegaZEl, tiltEl, headingEl, spinPhaseEl].forEach(el => 
      el.addEventListener('input', syncLabels)
    );

    function toggleControls() {
      const controls = document.getElementById('controls');
      const btn = document.getElementById('minimizeBtn');
      controls.classList.toggle('minimized');
      btn.textContent = controls.classList.contains('minimized') ? '+' : '-';
    }

    function togglePause() { 
      isPaused = !isPaused;
      if (!isPaused) {
        startAnimation();
      }
    }
    
    function emergencyStop() {
      isPaused = true;
      stopAnimation();
      console.log('Emergency stop activated');
    }

    function toggleTrails() {
      showTrails = !showTrails;
      if (!showTrails) ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function setRandomMotion() {
      initVelXEl.value = (Math.random() * 400 - 200).toFixed(0);
      initVelYEl.value = (Math.random() * 400 - 200).toFixed(0);
      initOmegaZEl.value = (Math.random() * 40 - 20).toFixed(1);
      tiltEl.value = (Math.random() * 20 + 70).toFixed(0);
      headingEl.value = (Math.random() * 360).toFixed(0);
      syncLabels();
      resetSimulation();
    }

    function setPureRoll() {
      // Set up for pure rolling motion: v = œâ √ó R
      const v = 150; // desired speed
      const R = Number(radiusEl.value);
      initVelXEl.value = v.toFixed(0);
      initVelYEl.value = "0";
      initOmegaZEl.value = (v / R).toFixed(1); // œâ = v/R for pure rolling
      tiltEl.value = "90"; // standing upright
      headingEl.value = "0";
      syncLabels();
      resetSimulation();
    }

    // Math helpers
    function vec3(x=0,y=0,z=0){ return new Float64Array([x,y,z]); }
    function add(a,b){ return vec3(a[0]+b[0], a[1]+b[1], a[2]+b[2]); }
    function sub(a,b){ return vec3(a[0]-b[0], a[1]-b[1], a[2]-b[2]); }
    function mul(a,s){ return vec3(a[0]*s, a[1]*s, a[2]*s); }
    function dot(a,b){ return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
    function cross(a,b){ return vec3(a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]); }
    function norm(a){ return Math.hypot(a[0], a[1], a[2]); }
    function normalize(a){ const n = norm(a) || 1; return vec3(a[0]/n, a[1]/n, a[2]/n); }

    function quat(w=1,x=0,y=0,z=0){ return new Float64Array([w,x,y,z]); }
    function quatMul(q1,q2){
      const [w1,x1,y1,z1] = q1, [w2,x2,y2,z2]=q2;
      return quat(
        w1*w2 - x1*x2 - y1*y2 - z1*z2,
        w1*x2 + x1*w2 + y1*z2 - z1*y2,
        w1*y2 - x1*z2 + y1*w2 + z1*x2,
        w1*z2 + x1*y2 - y1*x2 + z1*w2
      );
    }
    function quatNormalize(q){
      const n = Math.hypot(q[0],q[1],q[2],q[3]) || 1;
      q[0]/=n; q[1]/=n; q[2]/=n; q[3]/=n; return q;
    }
    function quatFromAxisAngle(axis, angle){
      const a = normalize(axis);
      const s = Math.sin(angle/2);
      return quat(Math.cos(angle/2), a[0]*s, a[1]*s, a[2]*s);
    }
    function quatRotate(q, v){
      const [w,x,y,z] = q;
      const vx = v[0], vy = v[1], vz = v[2];
      const ix =  w*vx + y*vz - z*vy;
      const iy =  w*vy + z*vx - x*vz;
      const iz =  w*vz + x*vy - y*vx;
      const iw = -x*vx - y*vy - z*vz;
      return vec3(
        ix*w + iw*-x + iy*-z - iz*-y,
        iy*w + iw*-y + iz*-x - ix*-z,
        iz*w + iw*-z + ix*-y - iy*-x
      );
    }
    function quatConjugate(q){ return quat(q[0], -q[1], -q[2], -q[3]); }

    function quatFromTwoVectors(a, b){
      const v0 = normalize(a), v1 = normalize(b);
      const c = dot(v0, v1);
      if (c < -0.999999){
        let axis = cross(vec3(1,0,0), v0);
        if (norm(axis) < 1e-6) axis = cross(vec3(0,1,0), v0);
        return quatFromAxisAngle(axis, Math.PI);
      }
      const axis = cross(v0, v1);
      const s = Math.sqrt((1+c)*2);
      const invs = 1/s;
      return quat(s*0.5, axis[0]*invs, axis[1]*invs, axis[2]*invs);
    }

    // Parameters and state
    let paramMass = 1.0;
    let paramRadius = 60; // px
    let paramThickness = 8; // px
    let paramTimeScale = 1.0;
    let paramGravity = 980; // px/s¬≤
    let paramDamping = 0.01;

    const zHat = vec3(0,0,1);
    const yHat = vec3(0,1,0);

    // Inertias (function of m,R,h)
    function inertiaTransverse(m, R, h){ return 0.25*m*R*R + (1/12)*m*h*h; } // I‚ä• = Ixx = Iyy
    function inertiaAxial(m, R){ return 0.5*m*R*R; } // I‚à• = Izz

    let I_perp = inertiaTransverse(paramMass, paramRadius, paramThickness);
    let I_axis = inertiaAxial(paramMass, paramRadius);

    // State variables
    let q = quat(1,0,0,0); // Orientation quaternion (world <- body)
    let pos = vec3(0,0,0); // Position of center of mass
    let vel = vec3(0,0,0); // Velocity of center of mass
    let omega = vec3(0,0,0); // Angular velocity (world frame)

    let isPaused = false;
    let showTrails = false;
    let showAxes = true;
    let showSpokes = true;

    function resetSimulation(){
      // Read UI parameters
      paramMass = Number(massEl.value);
      paramRadius = Number(radiusEl.value);
      paramThickness = Number(thicknessEl.value);
      paramTimeScale = Number(timeEl.value);
      paramGravity = Number(gravityEl.value);
      paramDamping = Number(dampingEl.value);

      I_perp = inertiaTransverse(paramMass, paramRadius, paramThickness);
      I_axis = inertiaAxial(paramMass, paramRadius);

      // Initial orientation from tilt Œ∏ (from vertical) and heading œà
      const theta = Number(tiltEl.value) * Math.PI/180; // 0..pi/2
      const psi = Number(headingEl.value) * Math.PI/180; // 0..2pi
      const n0 = normalize(vec3(Math.cos(psi)*Math.sin(theta), Math.sin(psi)*Math.sin(theta), Math.cos(theta)));
      
      // Rotate body z (0,0,1) to n0
      const qTilt = quatFromTwoVectors(vec3(0,0,1), n0);
      // Additional spin phase œÜ about n0
      const phi = Number(spinPhaseEl.value) * Math.PI/180;
      const qSpin = quatFromAxisAngle(n0, phi);
      q = quatNormalize(quatMul(qSpin, qTilt));

      // Initial position and velocity
      pos = vec3(canvas.width*0.5, canvas.height*0.5, 0);
      vel = vec3(Number(initVelXEl.value), Number(initVelYEl.value), 0);
      
      // Initial angular velocity (world frame)
      const initOmegaZ = Number(initOmegaZEl.value);
      omega = vec3(0, 0, initOmegaZ);

      if (!showTrails) ctx.clearRect(0,0,canvas.width, canvas.height);
      syncLabels();
      
      // Ensure animation is running after reset
      if (!animationId) {
        isPaused = false;
        startAnimation();
      }
    }

    function bodyFromWorld(v){ return quatRotate(quatConjugate(q), v); }
    function worldFromBody(v){ return quatRotate(q, v); }

    // Get the contact point (lowest point on rim)
    function getContactPoint(){
      const n = worldFromBody(vec3(0,0,1)); // coin normal in world frame
      const gravity_dir = vec3(0,0,-1); // gravity points down
      
      // Find the lowest point on the rim
      // The rim is a circle in the coin's plane, so we need the point on the rim
      // that is furthest in the gravity direction
      
      // Vector in coin plane that points "down" when projected to world
      const down_in_plane = normalize(sub(gravity_dir, mul(n, dot(n, gravity_dir))));
      
      // Contact point relative to center
      const r_contact_local = mul(down_in_plane, paramRadius);
      
      return add(pos, r_contact_local);
    }

    // Get vector from center of mass to contact point
    function getContactVector(){
      const n = worldFromBody(vec3(0,0,1)); // coin normal in world frame
      const gravity_dir = vec3(0,0,-1); // gravity points down
      
      // Vector in coin plane that points "down" when projected to world
      const down_in_plane = normalize(sub(gravity_dir, mul(n, dot(n, gravity_dir))));
      
      // Contact vector from center to contact point
      return mul(down_in_plane, paramRadius);
    }

    function update(dt){
      if (isPaused) return;
      const dtScaled = dt * paramTimeScale;

      // Get contact geometry
      const r_contact = getContactVector();
      const n = worldFromBody(vec3(0,0,1)); // coin normal
      
      // Check if coin is in contact with ground (z-component of contact point <= 0)
      const contact_pos = add(pos, r_contact);
      const in_contact = contact_pos[2] <= 0;
      
      if (in_contact) {
        // CONTACT MECHANICS
        
        // Apply no-slip constraint: v_contact = v_cm + omega √ó r_contact = 0
        // This gives us: v_cm = -omega √ó r_contact
        const v_contact_desired = vec3(0,0,0); // no slip
        const v_contact_current = add(vel, cross(omega, r_contact));
        
        // Constraint force to enforce no-slip
        const constraint_error = sub(v_contact_current, v_contact_desired);
        const constraint_strength = 10.0; // adjust for stiffness
        
        // Apply constraint correction to both linear and angular velocity
        const constraint_force = mul(constraint_error, -constraint_strength);
        
        // Effect on linear velocity
        vel = add(vel, mul(constraint_force, dtScaled / paramMass));
        
        // Effect on angular velocity (torque about center of mass)
        const constraint_torque = cross(r_contact, constraint_force);
        const omega_body = bodyFromWorld(omega);
        const torque_body = bodyFromWorld(constraint_torque);
        
        // Update angular velocity in body frame (using principal moments)
        omega_body[0] += torque_body[0] * dtScaled / I_perp;
        omega_body[1] += torque_body[1] * dtScaled / I_perp;
        omega_body[2] += torque_body[2] * dtScaled / I_axis;
        
        omega = worldFromBody(omega_body);
        
        // Constrain vertical position to keep contact point at ground level
        pos[2] = -r_contact[2];
        vel[2] = 0; // no vertical velocity when in contact
        
        // Apply damping when in contact
        vel = mul(vel, 1 - paramDamping * dtScaled);
        omega = mul(omega, 1 - paramDamping * dtScaled);
      } else {
        // FREE FALL
        // Apply gravity
        vel[2] -= paramGravity * dtScaled;
      }

      // Update position
      pos[0] += vel[0] * dtScaled;
      pos[1] += vel[1] * dtScaled;
      pos[2] += vel[2] * dtScaled;

      // Update orientation (integrate angular velocity)
      const omega_quat = quat(0, omega[0], omega[1], omega[2]);
      const q_dot = mul(quatMul(q, omega_quat), 0.5);
      q[0] += q_dot[0] * dtScaled;
      q[1] += q_dot[1] * dtScaled;
      q[2] += q_dot[2] * dtScaled;
      q[3] += q_dot[3] * dtScaled;
      quatNormalize(q);

      // Wrap around screen
      const Rpad = paramRadius + 10;
      if (pos[0] > canvas.width + Rpad) pos[0] = -Rpad;
      if (pos[0] < -Rpad) pos[0] = canvas.width + Rpad;
      if (pos[1] > canvas.height + Rpad) pos[1] = -Rpad;
      if (pos[1] < -Rpad) pos[1] = canvas.height + Rpad;
    }

    function draw(){
      if (!showTrails) ctx.clearRect(0,0,canvas.width, canvas.height);

      // Draw faint grid for plane (optimized)
      ctx.save();
      ctx.strokeStyle = 'rgba(80,100,160,0.15)';
      ctx.lineWidth = 1;
      const grid = 80;
      
      // Draw all vertical lines in one path
      ctx.beginPath();
      for (let x = 0; x < canvas.width; x += grid) {
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
      }
      ctx.stroke();
      
      // Draw all horizontal lines in one path
      ctx.beginPath();
      for (let y = 0; y < canvas.height; y += grid) {
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
      }
      ctx.stroke();
      
      ctx.restore();

      // Get orientation info
      const n = worldFromBody(vec3(0,0,1)); // coin normal
      const cosTheta = Math.max(-1, Math.min(1, dot(n, zHat)));
      const sinTheta = Math.sqrt(Math.max(0, 1 - cosTheta*cosTheta));
      const nProj = sub(n, mul(zHat, dot(n, zHat))); // projection onto plane
      const angleEllipse = (sinTheta > 1e-6) ? Math.atan2(nProj[1], nProj[0]) + Math.PI/2 : 0;

      // Ellipse radii (orthographic projection of tilted circle)
      const a = paramRadius;                  // major
      const b = paramRadius * Math.abs(cosTheta); // minor

      // Fill gradient hint
      const gx = pos[0] + (sinTheta > 1e-6 ? Math.cos(angleEllipse)*a*0.2 : 0);
      const gy = pos[1] + (sinTheta > 1e-6 ? Math.sin(angleEllipse)*a*0.2 : 0);
      const grad = ctx.createRadialGradient(gx, gy, Math.max(3, a*0.2), pos[0], pos[1], a);
      grad.addColorStop(0, 'rgba(180,200,255,0.9)');
      grad.addColorStop(1, 'rgba(40,60,140,0.9)');

      // Draw projected coin
      ctx.save();
      ctx.translate(pos[0], pos[1]);
      ctx.rotate(angleEllipse);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(0, 0, a, b, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.stroke();
      ctx.restore();

      // Draw spokes to visualize rotation
      if (showSpokes) {
        ctx.strokeStyle = 'rgba(255,255,255,0.75)';
        ctx.lineWidth = 1.5;
        const numSpokes = 12;
        for (let i = 0; i < numSpokes; i++) {
          const a = (i / numSpokes) * Math.PI * 2;
          const rWorld = worldFromBody(vec3(paramRadius * Math.cos(a), paramRadius * Math.sin(a), 0));
          ctx.beginPath();
          ctx.moveTo(pos[0], pos[1]);
          ctx.lineTo(pos[0] + rWorld[0], pos[1] + rWorld[1]);
          ctx.stroke();
        }
      }

      // Contact marker
      const contact_pos = getContactPoint();
      ctx.fillStyle = 'rgba(255,220,0,0.95)';
      ctx.beginPath();
      ctx.arc(contact_pos[0], contact_pos[1], 4, 0, Math.PI*2);
      ctx.fill();

      // Draw axes (projected body axes)
      if (showAxes) {
        ctx.save();
        ctx.lineWidth = 2;
        const axisLen = paramRadius;
        const ex = worldFromBody(vec3(1,0,0));
        const ey = worldFromBody(vec3(0,1,0));
        const ez = n;
        
        function drawVec(v, color, scale){
          ctx.strokeStyle = color;
          ctx.beginPath();
          ctx.moveTo(pos[0], pos[1]);
          ctx.lineTo(pos[0] + v[0]*scale, pos[1] + v[1]*scale);
          ctx.stroke();
        }
        
        drawVec(ex, 'rgba(255,80,80,0.95)', axisLen);      // X (red)
        drawVec(ey, 'rgba(120,255,120,0.95)', axisLen);    // Y (green)
        drawVec(nProj, 'rgba(120,180,255,0.95)', axisLen); // Z (blue)
        ctx.restore();
      }

      // Velocity vector
      ctx.save();
      ctx.strokeStyle = 'rgba(255,200,80,0.95)';
      ctx.lineWidth = 2;
      const velScale = 0.5;
      ctx.beginPath();
      ctx.moveTo(pos[0], pos[1]);
      ctx.lineTo(pos[0] + vel[0]*velScale, pos[1] + vel[1]*velScale);
      ctx.stroke();
      ctx.restore();

      // HUD
      ctx.save();
      ctx.fillStyle = 'rgba(200,220,255,0.9)';
      ctx.font = '12px Arial';
      const speed = norm(vel);
      const angSpeed = norm(omega);
      const r_contact = getContactVector();
      const contact_pos = add(pos, r_contact);
      const in_contact = contact_pos[2] <= 0;
      const energy_kinetic = 0.5 * paramMass * (vel[0]*vel[0] + vel[1]*vel[1] + vel[2]*vel[2]);
      const omega_body = bodyFromWorld(omega);
      const energy_rotational = 0.5 * (I_perp * (omega_body[0]*omega_body[0] + omega_body[1]*omega_body[1]) + I_axis * omega_body[2]*omega_body[2]);
      const energy_total = energy_kinetic + energy_rotational + paramMass * paramGravity * pos[2];
      
      const hud1 = `Speed: ${speed.toFixed(1)} px/s | œâ: ${angSpeed.toFixed(2)} rad/s | Contact: ${in_contact ? 'YES' : 'NO'}`;
      const hud2 = `Energy: KE=${energy_kinetic.toFixed(0)} + RE=${energy_rotational.toFixed(0)} + PE=${(paramMass * paramGravity * pos[2]).toFixed(0)} = ${energy_total.toFixed(0)}`;
      ctx.fillText(hud1, 12, 20);
      ctx.fillText(hud2, 12, 35);
      ctx.restore();
    }

    let animationId = null;
    let isAnimating = false;
    
    function animate(){
      if (isAnimating) return; // Prevent multiple animation loops
      isAnimating = true;
      
      const dt = 1/60;
      try {
        if (!isPaused) {
          update(dt);
        }
        draw();
        
        // Update debug info (less frequently to reduce overhead)
        if (frameCount % 10 === 0) {
          updatePerformanceDebug();
          updatePhysicsDebug();
        }
      } catch (error) {
        console.error('Animation loop error:', error.message, error.stack);
        // Pause animation on error to prevent freeze
        isPaused = true;
      }
      
      isAnimating = false;
      if (!isPaused || frameCount % 60 === 0) { // Still draw when paused, but less frequently
        animationId = requestAnimationFrame(animate);
      }
    }
    
    function stopAnimation() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      isAnimating = false;
    }
    
    function startAnimation() {
      if (!animationId) {
        animate();
      }
    }

    // Resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (!showTrails) ctx.clearRect(0,0,canvas.width, canvas.height);
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); togglePause(); }
      if (e.key.toLowerCase() === 't') toggleTrails();
      if (e.key.toLowerCase() === 'r') resetSimulation();
      if (e.code === 'Escape') { e.preventDefault(); emergencyStop(); }
      if (e.key.toLowerCase() === 's' && e.ctrlKey) { e.preventDefault(); emergencyStop(); }
    });

    // Init
    console.log('Starting initialization...');
    try {
      syncLabels();
      console.log('Labels synced successfully');
      resetSimulation();
      console.log('Simulation reset successfully');
      startAnimation();
      console.log('Animation started successfully');
      console.log('=== 3D Coin App Ready ===');
      console.log('Emergency controls: ESC key or Ctrl+S to stop animation');
    } catch (error) {
      console.error('Initialization failed:', error.message, error.stack);
      // Try to show an error message to the user
      const errorDiv = document.createElement('div');
      errorDiv.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:red; color:white; padding:20px; border-radius:10px; z-index:1000;';
      errorDiv.innerHTML = `<h3>App Failed to Start</h3><p>${error.message}</p><p>Check console for details</p>`;
      document.body.appendChild(errorDiv);
    }
  </script>
</body>
</html> 
