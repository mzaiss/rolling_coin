<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Rolling Coin Simulator (No Slip)</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000011;
      font-family: 'Arial', sans-serif;
      overflow: hidden;
      color: white;
    }

    #controls {
      position: fixed;
      top: 10px;
      left: 10px;
      right: 10px;
      background: rgba(0,0,0,0.9);
      padding: 15px;
      border-radius: 10px;
      border: 2px solid #4444ff;
      z-index: 100;
      max-height: 60vh;
      overflow-y: auto;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    #controls.minimized {
      max-height: 50px;
      overflow: hidden;
    }

    #controls.minimized .control-content {
      display: none;
    }

    #minimizeBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #4444ff;
      border: none;
      color: white;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
    }

    @media (max-width: 768px) {
      #controls {
        top: 5px;
        left: 5px;
        right: 5px;
        padding: 10px;
        font-size: 12px;
        max-height: 50vh;
      }

      .control-group { margin: 8px 0; }
      label { font-size: 11px; margin-bottom: 3px; }
      select, input { width: 100%; padding: 6px; font-size: 12px; }
      .button { padding: 8px 12px; font-size: 11px; margin: 3px; }
    }

    .control-group { margin: 8px 0; display: flex; flex-direction: column; }
    .control-row { display: flex; gap: 15px; align-items: flex-start; }
    .control-column { flex: 1; display: flex; flex-direction: column; gap: 8px; }
    .button-row { display: flex; flex-wrap: wrap; gap: 5px; }

    label {
      display: block;
      margin-bottom: 5px;
      color: #88aaff;
      font-weight: bold;
    }

    select, input {
      width: 100%;
      max-width: 220px;
      padding: 8px;
      border-radius: 5px;
      border: 1px solid #4444ff;
      background: #001122;
      color: white;
      font-size: 14px;
    }

    .button {
      background: linear-gradient(45deg, #4444ff, #8888ff);
      border: none;
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      margin: 5px;
      font-weight: bold;
    }

    .button:hover { background: linear-gradient(45deg, #6666ff, #aaaaff); }

    .copyright {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: #6666aa;
      font-size: 12px;
      font-family: 'Arial', sans-serif;
      z-index: 100;
      background: rgba(0,0,0,0.7);
      padding: 5px 10px;
      border-radius: 5px;
    }

    .ground {
      position: fixed;
      bottom: 0;
      width: 100%;
      height: 80px;
      background: linear-gradient(0deg, rgba(20,30,60,0.9), rgba(0,0,0,0));
      pointer-events: none;
    }

    #debugPanel {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 300px;
      max-height: 80vh;
      background: rgba(0,0,0,0.95);
      border: 2px solid #ff4444;
      border-radius: 8px;
      padding: 10px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #00ff00;
      overflow-y: auto;
      z-index: 200;
      display: none;
    }

    #debugPanel.visible {
      display: block;
    }

    #debugPanel h4 {
      margin: 0 0 10px 0;
      color: #ff4444;
      font-size: 12px;
    }

    #debugLog {
      background: rgba(0,0,0,0.8);
      border: 1px solid #333;
      padding: 8px;
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 10px;
      word-wrap: break-word;
    }

    .debug-section {
      margin-bottom: 10px;
      padding: 5px;
      border: 1px solid #333;
      border-radius: 3px;
    }

    .debug-toggle {
      position: fixed;
      top: 10px;
      right: 10px;
      background: #ff4444;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      z-index: 300;
      font-size: 11px;
    }

    @media (max-width: 768px) {
      #debugPanel {
        width: calc(100vw - 20px);
        right: 10px;
        left: 10px;
        top: 60px;
        max-height: 60vh;
      }
      .debug-toggle {
        top: 60px;
        right: 15px;
      }
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="minimizeBtn" onclick="toggleControls()">-</button>
    <h3>Rolling Coin Controls</h3>
    <div class="control-content">
      <div class="control-row">
        <div class="control-column">
          <div class="control-group">
            <label>Mass (m)</label>
            <input type="range" id="mass" min="0.1" max="10" step="0.1" value="1.0">
            <span id="massValue">1.0</span>
          </div>
          <div class="control-group">
            <label>Radius (R)</label>
            <input type="range" id="radius" min="20" max="150" step="1" value="60">
            <span id="radiusValue">60</span>
          </div>
        </div>
        <div class="control-column">
          <div class="control-group">
            <label>Initial Angular Momentum (L)</label>
            <input type="range" id="angMomentum" min="-400" max="400" step="1" value="120">
            <span id="angMomentumValue">120</span>
          </div>
          <div class="control-group">
            <label>Time Scale</label>
            <input type="range" id="timeScale" min="0.1" max="30" step="0.1" value="3">
            <span id="timeScaleValue">3.0</span>
          </div>
        </div>
      </div>
      <div class="button-row">
        <button class="button" onclick="resetSimulation()">Reset</button>
        <button class="button" onclick="togglePause()">Pause</button>
        <button class="button" onclick="toggleTrails()">Trails</button>
        <button class="button" onclick="toggleContactTrail()">Contact Trail</button>
        <button class="button" onclick="toggleVelocityVectors()">Show Velocities</button>
      </div>
      <div>
        <small>No-slip constraint: v = R·ω with ω = L / I and I = ½ m R². The coin's contact point has zero velocity relative to the ground.</small>
      </div>
    </div>
  </div>

  <div class="ground"></div>
  <div class="copyright">© M.Zaiss'25 · Rolling Coin · <a href="index.html" target="_blank" style="color:#8888cc; text-decoration:none;">Planets</a></div>

  <button class="debug-toggle" id="debugToggle" onclick="toggleDebugPanel()">DEBUG</button>
  
  <div id="debugPanel">
    <h4>🐛 2D Coin Debug Console</h4>
    
    <div class="debug-section">
      <div><strong>Error Log:</strong></div>
      <div id="debugLog"></div>
    </div>
    
    <div class="debug-section">
      <div><strong>Performance:</strong></div>
      <div id="debugPerf">
        FPS: <span id="fps">--</span><br>
        Frame Time: <span id="frameTime">--</span>ms<br>
        Memory: <span id="memory">--</span>MB
      </div>
    </div>
    
    <div class="debug-section">
      <div><strong>Coin State:</strong></div>
      <div id="debugState">
        Position: <span id="posDebug">--</span><br>
        Velocity: <span id="velDebug">--</span><br>
        Angular Vel: <span id="omegaDebug">--</span><br>
        Angle: <span id="angleDebug">--</span><br>
        Angular Momentum: <span id="angMomentumDebug">--</span>
      </div>
    </div>
    
    <div class="debug-section">
      <div><strong>Physics Check:</strong></div>
      <div id="debugPhysics">
        v = R·ω: <span id="noSlipCheck">--</span><br>
        Contact Speed: <span id="contactSpeedDebug">--</span><br>
        Moment of Inertia: <span id="inertiaDebug">--</span>
      </div>
    </div>
    
    <div class="debug-section">
      <div><strong>Browser Info:</strong></div>
      <div id="debugBrowser">
        User Agent: <span id="userAgent">--</span><br>
        Screen: <span id="screenSize">--</span><br>
        Viewport: <span id="viewportSize">--</span><br>
        Device Pixel Ratio: <span id="pixelRatio">--</span><br>
        Touch Support: <span id="touchSupport">--</span>
      </div>
    </div>
    
    <div class="debug-section">
      <div><strong>Canvas Info:</strong></div>
      <div id="debugCanvas">
        Canvas Size: <span id="canvasSize">--</span><br>
        Context: <span id="contextType">--</span><br>
        WebGL Support: <span id="webglSupport">--</span>
      </div>
    </div>
    
    <div class="debug-section">
      <button onclick="clearDebugLog()" style="background:#666;color:white;border:none;padding:4px 8px;border-radius:3px;">Clear Log</button>
      <button onclick="exportDebugInfo()" style="background:#666;color:white;border:none;padding:4px 8px;border-radius:3px;">Export Info</button>
    </div>
  </div>

  <script>
    // Debug system - Initialize early to catch all errors
    let debugPanel = null;
    let debugVisible = false;
    let debugLog = [];
    let lastFrameTime = performance.now();
    let frameCount = 0;
    let fpsUpdateTime = 0;
    
    // Override console methods to capture logs
    const originalConsole = {
      log: console.log,
      error: console.error,
      warn: console.warn,
      info: console.info
    };
    
    function addToDebugLog(type, message, timestamp = new Date()) {
      const logEntry = {
        type,
        message: String(message),
        timestamp: timestamp.toISOString().split('T')[1].slice(0, -1)
      };
      debugLog.push(logEntry);
      
      // Keep only last 100 entries
      if (debugLog.length > 100) {
        debugLog.shift();
      }
      
      updateDebugLogDisplay();
      
      // Call original console method
      if (originalConsole[type]) {
        originalConsole[type].apply(console, arguments);
      }
    }
    
    // Override console methods
    console.log = (...args) => addToDebugLog('log', args.join(' '));
    console.error = (...args) => addToDebugLog('error', args.join(' '));
    console.warn = (...args) => addToDebugLog('warn', args.join(' '));
    console.info = (...args) => addToDebugLog('info', args.join(' '));
    
    // Catch unhandled errors
    window.addEventListener('error', (event) => {
      addToDebugLog('error', `Unhandled Error: ${event.message} at ${event.filename}:${event.lineno}`);
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      addToDebugLog('error', `Unhandled Promise Rejection: ${event.reason}`);
    });
    
    function toggleDebugPanel() {
      debugVisible = !debugVisible;
      debugPanel = debugPanel || document.getElementById('debugPanel');
      if (debugPanel) {
        debugPanel.classList.toggle('visible', debugVisible);
        if (debugVisible) {
          updateAllDebugInfo();
        }
      }
    }
    
    function updateDebugLogDisplay() {
      const logElement = document.getElementById('debugLog');
      if (!logElement || !debugVisible) return;
      
      const logHtml = debugLog.slice(-20).map(entry => {
        const color = {
          error: '#ff4444',
          warn: '#ffaa44',
          info: '#4444ff',
          log: '#00ff00'
        }[entry.type] || '#00ff00';
        
        return `<div style="color:${color};">[${entry.timestamp}] ${entry.type.toUpperCase()}: ${entry.message}</div>`;
      }).join('');
      
      logElement.innerHTML = logHtml;
      logElement.scrollTop = logElement.scrollHeight;
    }
    
    function clearDebugLog() {
      debugLog = [];
      updateDebugLogDisplay();
    }
    
    function exportDebugInfo() {
      const info = {
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        screen: `${screen.width}x${screen.height}`,
        viewport: `${window.innerWidth}x${window.innerHeight}`,
        devicePixelRatio: window.devicePixelRatio,
        touchSupport: 'ontouchstart' in window,
        logs: debugLog,
        canvasSize: canvas ? `${canvas.width}x${canvas.height}` : 'N/A',
        webglSupport: !!window.WebGLRenderingContext,
        coinState: {
          coinX: coinX,
          coinY: coinY,
          coinAngle: coinAngle,
          omega: omega,
          vx: vx,
          paramMass: paramMass,
          paramRadius: paramRadius,
          paramL: paramL
        }
      };
      
      const dataStr = JSON.stringify(info, null, 2);
      const blob = new Blob([dataStr], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'coin-debug-info.json';
      a.click();
      URL.revokeObjectURL(url);
    }
    
    function updateAllDebugInfo() {
      if (!debugVisible) return;
      
      // Browser info
      document.getElementById('userAgent').textContent = navigator.userAgent.slice(0, 50) + '...';
      document.getElementById('screenSize').textContent = `${screen.width}x${screen.height}`;
      document.getElementById('viewportSize').textContent = `${window.innerWidth}x${window.innerHeight}`;
      document.getElementById('pixelRatio').textContent = window.devicePixelRatio;
      document.getElementById('touchSupport').textContent = 'ontouchstart' in window ? 'Yes' : 'No';
      
      // Canvas info
      if (canvas) {
        document.getElementById('canvasSize').textContent = `${canvas.width}x${canvas.height}`;
        document.getElementById('contextType').textContent = ctx ? '2D' : 'None';
      }
      document.getElementById('webglSupport').textContent = !!window.WebGLRenderingContext ? 'Yes' : 'No';
      
      // Memory info (if available)
      if (performance.memory) {
        const memMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
        document.getElementById('memory').textContent = memMB;
      }
    }
    
    function updatePerformanceDebug() {
      if (!debugVisible) return;
      
      const now = performance.now();
      const deltaTime = now - lastFrameTime;
      lastFrameTime = now;
      frameCount++;
      
      // Update FPS every second
      if (now - fpsUpdateTime > 1000) {
        const fps = Math.round(frameCount * 1000 / (now - fpsUpdateTime));
        document.getElementById('fps').textContent = fps;
        frameCount = 0;
        fpsUpdateTime = now;
      }
      
      document.getElementById('frameTime').textContent = deltaTime.toFixed(1);
    }
    
    function updateCoinDebug() {
      if (!debugVisible) return;
      
      try {
        document.getElementById('posDebug').textContent = `(${coinX.toFixed(1)}, ${coinY.toFixed(1)})`;
        document.getElementById('velDebug').textContent = `${vx.toFixed(1)} px/s`;
        document.getElementById('omegaDebug').textContent = `${omega.toFixed(3)} rad/s`;
        document.getElementById('angleDebug').textContent = `${(coinAngle * 180 / Math.PI).toFixed(1)}°`;
        document.getElementById('angMomentumDebug').textContent = `${paramL.toFixed(1)}`;
        
        // Physics checks
        const I = momentOfInertia(paramMass, paramRadius);
        const expectedV = omega * paramRadius;
        const noSlipError = Math.abs(vx - expectedV);
        document.getElementById('noSlipCheck').textContent = `${vx.toFixed(1)} ≈ ${expectedV.toFixed(1)} (error: ${noSlipError.toFixed(3)})`;
        
        const contactRel = { x: Math.sin(coinAngle) * paramRadius, y: paramRadius };
        const contactVel = getPointVelocity(contactRel.x, contactRel.y);
        const contactSpeed = Math.sqrt(contactVel.x * contactVel.x + contactVel.y * contactVel.y);
        document.getElementById('contactSpeedDebug').textContent = `${contactSpeed.toFixed(3)} px/s`;
        
        document.getElementById('inertiaDebug').textContent = `${I.toFixed(2)}`;
      } catch (e) {
        document.getElementById('posDebug').textContent = 'Error reading state: ' + e.message;
      }
    }
    
    // Mobile touch debugging
    function setupTouchDebugging() {
      ['touchstart', 'touchmove', 'touchend', 'touchcancel'].forEach(eventType => {
        document.addEventListener(eventType, (e) => {
          console.log(`Touch ${eventType}: ${e.touches.length} touches, target:${e.target.tagName}`);
        }, { passive: false });
      });
      
      // Add orientation change debugging
      window.addEventListener('orientationchange', () => {
        console.log('Orientation changed to:', window.orientation || screen.orientation?.angle || 'unknown');
        setTimeout(() => {
          console.log('New viewport size after orientation change:', window.innerWidth + 'x' + window.innerHeight);
        }, 100);
      });
      
      // Add visibility change debugging
      document.addEventListener('visibilitychange', () => {
        console.log('Visibility changed. Hidden:', document.hidden);
      });
      
      // Add focus debugging
      window.addEventListener('focus', () => console.log('Window gained focus'));
      window.addEventListener('blur', () => console.log('Window lost focus'));
    }

    // Log initial startup
    console.log('=== 2D Rolling Coin App Starting ===');
    console.log('User Agent:', navigator.userAgent);
    console.log('Screen size:', screen.width + 'x' + screen.height);
    console.log('Viewport size:', window.innerWidth + 'x' + window.innerHeight);
    console.log('Device pixel ratio:', window.devicePixelRatio);
    console.log('Touch support:', 'ontouchstart' in window);
    console.log('Orientation:', window.orientation || screen.orientation?.angle || 'unknown');
    
    // Setup mobile debugging
    setupTouchDebugging();

    // Canvas setup
    const canvas = document.createElement('canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    document.body.appendChild(canvas);
    const ctx = canvas.getContext('2d');
    
    console.log('Canvas created:', canvas.width + 'x' + canvas.height);
    console.log('2D context available:', !!ctx);

    // Simulation parameters
    let paramMass = 1.0;
    let paramRadius = 60; // pixels, also used as length unit for drawing
    let paramL = 120; // angular momentum magnitude (arbitrary units)
    let paramTimeScale = 3.0;

    // State variables
    let coinX = 200; // center x (px)
    let coinY = 0;   // computed from ground - radius
    let coinAngle = 0; // orientation angle (rad)
    let omega = 0;     // angular velocity (rad/s)
    let vx = 0;        // linear velocity (px/s)

    let isPaused = false;
    let showTrails = false;
    let showContactTrail = false;
    let showVelocityVectors = false;
    
    // Contact point trail storage
    let contactTrail = [];
    const maxTrailLength = 500;

    // UI wiring
    const massEl = document.getElementById('mass');
    const radiusEl = document.getElementById('radius');
    const LEl = document.getElementById('angMomentum');
    const timeEl = document.getElementById('timeScale');

    function syncLabels() {
      document.getElementById('massValue').textContent = Number(massEl.value).toFixed(1);
      document.getElementById('radiusValue').textContent = Number(radiusEl.value).toFixed(0);
      document.getElementById('angMomentumValue').textContent = Number(LEl.value).toFixed(0);
      document.getElementById('timeScaleValue').textContent = Number(timeEl.value).toFixed(1);
    }

    // Live-apply parameter changes to maintain no-slip without requiring Reset
    function applyNoSlipParams() {
      paramMass = Number(massEl.value);
      paramRadius = Number(radiusEl.value);
      paramL = Number(LEl.value);
      const I = momentOfInertia(paramMass, paramRadius);
      omega = I > 0 ? (paramL / I) : 0; // ω = L / I
      vx = omega * paramRadius;         // v = R · ω
      // Keep the coin in contact with the ground as R changes
      coinY = canvas.height - 60 - paramRadius;
      syncLabels();
    }

    massEl.addEventListener('input', applyNoSlipParams);
    radiusEl.addEventListener('input', applyNoSlipParams);
    LEl.addEventListener('input', applyNoSlipParams);
    timeEl.addEventListener('input', () => { syncLabels(); paramTimeScale = Number(timeEl.value); });

    function toggleControls() {
      const controls = document.getElementById('controls');
      const btn = document.getElementById('minimizeBtn');
      controls.classList.toggle('minimized');
      btn.textContent = controls.classList.contains('minimized') ? '+' : '-';
    }

    function togglePause() { isPaused = !isPaused; }

    function toggleTrails() {
      showTrails = !showTrails;
      if (!showTrails) ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    
    function toggleContactTrail() {
      showContactTrail = !showContactTrail;
      if (!showContactTrail) {
        contactTrail = [];
      }
    }
    
    function toggleVelocityVectors() {
      showVelocityVectors = !showVelocityVectors;
    }

    function momentOfInertia(m, R) { return 0.5 * m * R * R; }

    function resetSimulation() {
      // Read UI
      paramMass = Number(massEl.value);
      paramRadius = Number(radiusEl.value);
      paramL = Number(LEl.value);
      paramTimeScale = Number(timeEl.value);
      syncLabels();

      // Place coin and compute state that satisfies no-slip with given L
      coinY = canvas.height - 60 - paramRadius; // 60px visual ground height
      coinX = Math.max(paramRadius + 20, 200);
      coinAngle = 0;

      const I = momentOfInertia(paramMass, paramRadius);
      omega = I > 0 ? (paramL / I) : 0; // ω = L / I
      vx = omega * paramRadius;         // v = R · ω (no slip)

      // Clear canvas if trails off
      if (!showTrails) ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Clear contact trail
      contactTrail = [];
    }

    // Calculate contact point position in world coordinates
    function getContactPoint() {
      // Contact point is at the bottom of the coin
      const contactX = coinX + Math.sin(coinAngle) * paramRadius;
      const contactY = coinY + paramRadius;  // Should be exactly at ground level
      return { x: contactX, y: contactY };
    }

    // Calculate velocity of a point on the coin
    function getPointVelocity(relativeX, relativeY) {
      // For a point at relative position (rx, ry) from center:
      // v_point = v_center + ω × r
      // In 2D: v_point = (vx - ω * ry, vy + ω * rx)
      return {
        x: vx - omega * relativeY,
        y: 0 + omega * relativeX
      };
    }

    // Draw coin and ground
    function draw() {
      if (!showTrails) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      // Ground line
      ctx.save();
      ctx.strokeStyle = '#224488';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height - 60);
      ctx.lineTo(canvas.width, canvas.height - 60);
      ctx.stroke();
      
      // Draw grid marks on ground for reference
      ctx.strokeStyle = '#112244';
      ctx.lineWidth = 1;
      for (let x = 0; x < canvas.width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, canvas.height - 60);
        ctx.lineTo(x, canvas.height - 55);
        ctx.stroke();
      }
      ctx.restore();

      // Draw contact trail before coin
      if (showContactTrail && contactTrail.length > 1) {
        ctx.save();
        ctx.strokeStyle = 'rgba(255,100,100,0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(contactTrail[0].x, contactTrail[0].y);
        for (let i = 1; i < contactTrail.length; i++) {
          ctx.lineTo(contactTrail[i].x, contactTrail[i].y);
        }
        ctx.stroke();
        ctx.restore();
      }

      // Coin body
      ctx.save();
      ctx.translate(coinX, coinY);
      
      // Draw velocity vectors if enabled
      if (showVelocityVectors) {
        // Center velocity
        ctx.save();
        ctx.strokeStyle = 'rgba(0,255,0,0.8)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(vx * 0.5, 0); // Scale for visibility
        ctx.stroke();
        ctx.fillStyle = 'rgba(0,255,0,0.8)';
        ctx.fillText('v_center', 5, -5);
        ctx.restore();
        
        // Contact point velocity (should be zero!)
        const contactRel = { x: Math.sin(coinAngle) * paramRadius, y: paramRadius };
        const contactVel = getPointVelocity(contactRel.x, contactRel.y);
        ctx.save();
        ctx.translate(contactRel.x, contactRel.y);
        ctx.strokeStyle = 'rgba(255,0,0,0.8)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(contactVel.x * 0.5, contactVel.y * 0.5); // Should be nearly zero
        ctx.stroke();
        ctx.fillStyle = 'rgba(255,0,0,0.8)';
        ctx.fillText(`v_contact: (${contactVel.x.toFixed(1)}, ${contactVel.y.toFixed(1)})`, 5, 15);
        ctx.restore();
        
        // Top point velocity (should be 2x center velocity)
        const topRel = { x: -Math.sin(coinAngle) * paramRadius, y: -paramRadius };
        const topVel = getPointVelocity(topRel.x, topRel.y);
        ctx.save();
        ctx.translate(topRel.x, topRel.y);
        ctx.strokeStyle = 'rgba(100,100,255,0.8)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(topVel.x * 0.5, topVel.y * 0.5);
        ctx.stroke();
        ctx.fillStyle = 'rgba(100,100,255,0.8)';
        ctx.fillText('v_top', 5, -5);
        ctx.restore();
      }
      
      const gradient = ctx.createRadialGradient(0, -paramRadius*0.4, paramRadius*0.2, 0, 0, paramRadius);
      gradient.addColorStop(0, 'hsl(220, 80%, 70%)');
      gradient.addColorStop(1, 'hsl(220, 80%, 30%)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, paramRadius, 0, Math.PI * 2);
      ctx.fill();

      // Rim
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, 0, paramRadius, 0, Math.PI * 2);
      ctx.stroke();

      // Spokes/ticks to visualize rotation
      ctx.rotate(coinAngle);
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = 2;
      const numSpokes = 12;
      for (let i = 0; i < numSpokes; i++) {
        const a = (i / numSpokes) * Math.PI * 2;
        ctx.save();
        ctx.rotate(a);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, -paramRadius);
        ctx.stroke();
        
        // Add numbers to some spokes for better rotation visibility
        if (i % 3 === 0) {
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.font = '14px Arial';
          ctx.fillText(String(i/3), -5, -paramRadius + 15);
        }
        ctx.restore();
      }

      // Contact point marker (larger and more visible)
      ctx.save();
      ctx.rotate(-coinAngle); // undo to draw at world orientation
      ctx.fillStyle = 'rgba(255,50,50,0.9)';
      ctx.beginPath();
      ctx.arc(0, paramRadius, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.9)';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();

      ctx.restore();

      // HUD text
      ctx.save();
      ctx.fillStyle = 'rgba(200,220,255,0.9)';
      ctx.font = '12px Arial';
      const I = momentOfInertia(paramMass, paramRadius);
      const info = `m=${paramMass.toFixed(1)}  R=${paramRadius.toFixed(0)}  I=½mR²=${I.toFixed(1)}  L=${paramL.toFixed(0)}  ω=${omega.toFixed(2)} rad/s  v=${vx.toFixed(2)} px/s`;
      ctx.fillText(info, 12, 20);
      
      // Contact point verification
      const contactVel = getPointVelocity(Math.sin(coinAngle) * paramRadius, paramRadius);
      const contactSpeed = Math.sqrt(contactVel.x * contactVel.x + contactVel.y * contactVel.y);
      ctx.fillText(`Contact point speed: ${contactSpeed.toFixed(3)} px/s (should be ≈0)`, 12, 40);
      
      ctx.restore();
    }

    function update(dt) {
      if (isPaused) return;
      const dtScaled = dt * paramTimeScale;

      // Enforce no-slip at all times using current ω
      // With no torques, L is constant -> ω constant (unless user resets)
      coinX += vx * dtScaled;
      coinAngle += omega * dtScaled;
      
      // Track contact point
      if (showContactTrail) {
        const contact = getContactPoint();
        contactTrail.push(contact);
        if (contactTrail.length > maxTrailLength) {
          contactTrail.shift();
        }
      }

      // Wrap-around so the coin stays on screen
      const wrapLeft = -paramRadius - 5;
      const wrapRight = canvas.width + paramRadius + 5;
      if (coinX > wrapRight) {
        coinX = wrapLeft;
        if (showContactTrail) {
          // Add a break in the trail
          contactTrail = [];
        }
      }
      if (coinX < wrapLeft) {
        coinX = wrapRight;
        if (showContactTrail) {
          contactTrail = [];
        }
      }
    }

    function animate() {
      const dt = 1/60; // seconds
      try {
        update(dt);
        draw();
        
        // Update debug info
        updatePerformanceDebug();
        updateCoinDebug();
      } catch (error) {
        console.error('Animation loop error:', error.message, error.stack);
      }
      requestAnimationFrame(animate);
    }

    // Resize handler
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      // Keep coin on ground
      coinY = canvas.height - 60 - paramRadius;
      if (!showTrails) ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    // Init
    console.log('Starting initialization...');
    try {
      syncLabels();
      console.log('Labels synced successfully');
      resetSimulation();
      console.log('Simulation reset successfully');
      animate();
      console.log('Animation started successfully');
      console.log('=== 2D Rolling Coin App Ready ===');
    } catch (error) {
      console.error('Initialization failed:', error.message, error.stack);
    }
  </script>
</body>
</html>